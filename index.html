<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rubber</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.6/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        h1 {
            margin-bottom: 20px;
            color: #333;
        }
        .filters {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .filter-group label {
            font-weight: bold;
            font-size: 14px;
            color: #555;
        }
        .filter-actions {
            display: flex;
            gap: 8px;
            margin-bottom: 6px;
        }
        .filter-actions button {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            background: #fff;
            cursor: pointer;
        }
        .filter-actions button:hover {
            background: #f5f5f5;
        }
        .filter-search {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            min-width: 200px;
        }
        .filter-options {
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #fff;
            min-width: 200px;
            max-height: 160px;
            overflow: auto;
            padding: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .filter-option {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #333;
        }
        .filter-option input[type="checkbox"] {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
            pointer-events: none;
        }
        .custom-check {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            border: 1px solid #999;
            background: #fff;
            display: inline-block;
            position: relative;
            flex-shrink: 0;
        }
        .filter-option input[type="checkbox"]:focus-visible + .custom-check {
            outline: 2px solid #4c9ffe;
            outline-offset: 2px;
        }
        .filter-option input[type="checkbox"]:checked + .custom-check::after {
            content: '';
            position: absolute;
            inset: 3px;
            border-radius: 2px;
            background: #333;
        }
        .custom-check.color-check {
            border-radius: 3px;
            border: 1px solid #ccc;
        }
        .custom-check.color-check::after {
            content: '';
            position: absolute;
            inset: 2px;
            border-radius: 2px;
        }
        .filter-option input[type="checkbox"]:checked + .custom-check.color-check::after {
            box-shadow: 0 0 0 1px #333;
        }
        .custom-check.shape-check {
            border: 1px solid #333;
            background: #fff;
        }
        .custom-check.shape-check.circle {
            border-radius: 50%;
        }
        .custom-check.shape-check.square {
            border-radius: 2px;
        }
        .custom-check.shape-check.diamond {
            transform: rotate(45deg);
        }
        .filter-option input[type="checkbox"]:checked + .custom-check.shape-check::after {
            content: '';
            position: absolute;
            inset: 3px;
            background: #333;
        }
        .custom-check.shape-check.diamond::after {
            transform: rotate(-45deg);
        }
        .color-swatch {
            width: 12px;
            height: 12px;
            border-radius: 3px;
            border: 1px solid #ccc;
            flex-shrink: 0;
        }
        .shape-swatch {
            width: 12px;
            height: 12px;
            border: 1px solid #333;
            background: #fff;
            flex-shrink: 0;
        }
        .shape-swatch.circle {
            border-radius: 50%;
        }
        .shape-swatch.square {
            border-radius: 2px;
        }
        .shape-swatch.diamond {
            transform: rotate(45deg);
        }
        .filter-instructions {
            font-size: 12px;
            color: #888;
            font-style: italic;
        }
        #chart {
            width: 100%;
            height: 600px;
            margin-bottom: 20px;
            touch-action: none;
        }
        .details-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .detail-panel {
            flex: 1;
            min-width: 300px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: #fafafa;
            min-height: 200px;
        }
        .detail-panel h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 18px;
        }
        .detail-panel .content {
            color: #666;
            line-height: 1.6;
        }
        .detail-panel a {
            color: #0066cc;
            text-decoration: none;
        }
        .detail-panel a:hover {
            text-decoration: underline;
        }
        .comparison-bar {
            margin-top: 20px;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 8px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            color: #1976d2;
        }
        @media (max-width: 768px) {
            .details-container {
                flex-direction: column;
            }
            .detail-panel:nth-child(2) {
                display: none;
            }
            #chart {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèì Rubber</h1>

        <div id="chart"></div>
        
        <div class="filters">
            <div class="filter-group">
                <label>Company:</label>
                <div class="filter-actions">
                    <button type="button" data-filter="company" data-action="all">All</button>
                    <button type="button" data-filter="company" data-action="none">None</button>
                </div>
                <input id="companySearch" class="filter-search" type="search" placeholder="Search company">
                <div id="companyFilter" class="filter-options"></div>
            </div>
            <div class="filter-group">
                <label>Rubber:</label>
                <div class="filter-actions">
                    <button type="button" data-filter="name" data-action="all">All</button>
                    <button type="button" data-filter="name" data-action="none">None</button>
                </div>
                <input id="nameSearch" class="filter-search" type="search" placeholder="Search rubber">
                <div id="nameFilter" class="filter-options"></div>
            </div>
            <div class="filter-group">
                <label>Tackiness:</label>
                <div class="filter-actions">
                    <button type="button" data-filter="tackiness" data-action="all">All</button>
                    <button type="button" data-filter="tackiness" data-action="none">None</button>
                </div>
                <div id="tackinessFilter" class="filter-options"></div>
            </div>
            <div class="filter-group">
                <label>Hardness:</label>
                <div class="filter-actions">
                    <button type="button" data-filter="hardness" data-action="all">All</button>
                    <button type="button" data-filter="hardness" data-action="none">None</button>
                </div>
                <div id="hardnessFilter" class="filter-options"></div>
            </div>
        </div>

        

        <div class="details-container">
            <div class="detail-panel" id="detail1">
                <h3>Select a rubber</h3>
                <div class="content">Click on any dot to see details</div>
            </div>
            <div class="detail-panel" id="detail2">
                <h3>Select another rubber</h3>
                <div class="content">Click on another dot to compare</div>
            </div>
        </div>

        <div id="comparisonBar" style="display: none;" class="comparison-bar"></div>
    </div>

    <script>
        // Rubber data (loaded from /rubbers/*.json)
        let rubberData = [];
        let descriptions = {};

        const rubberFiles = [
            'rubbers/Andro.json',
            'rubbers/Butterfly.json',
            'rubbers/DHS.json',
            'rubbers/Donic.json',
            'rubbers/JOOLA.json',
            'rubbers/Nittaku.json',
            'rubbers/Tibhar.json',
            'rubbers/Xiom.json',
            'rubbers/Yasaka.json'
        ];

        function parseRatingNumber(value) {
            if (typeof value === 'number') return value;
            if (typeof value !== 'string') return null;
            const match = value.match(/[\d.]+/);
            if (!match) return null;
            const parsed = Number.parseFloat(match[0]);
            return Number.isFinite(parsed) ? parsed : null;
        }

        function buildManufacturerRatingRanges(rawItems) {
            const ranges = {};
            rawItems.forEach(raw => {
                const manufacturer = raw.manufacturer;
                const ratings = raw.manufacturer_ratings || {};
                if (!manufacturer || typeof ratings !== 'object') {
                    return;
                }

                const speed = parseRatingNumber(ratings.speed);
                const spin = parseRatingNumber(ratings.spin);
                if (!ranges[manufacturer]) {
                    ranges[manufacturer] = {
                        speed: { min: Infinity, max: -Infinity },
                        spin: { min: Infinity, max: -Infinity }
                    };
                }
                const range = ranges[manufacturer];
                if (Number.isFinite(speed)) {
                    range.speed.min = Math.min(range.speed.min, speed);
                    range.speed.max = Math.max(range.speed.max, speed);
                }
                if (Number.isFinite(spin)) {
                    range.spin.min = Math.min(range.spin.min, spin);
                    range.spin.max = Math.max(range.spin.max, spin);
                }
            });
            return ranges;
        }

        function normalizeManufacturerRating(value, range) {
            if (!Number.isFinite(value) || !range) {
                return null;
            }
            const max = range.max;
            if (!Number.isFinite(max) || max <= 0) {
                return null;
            }
            return (value / max) * 10;
        }

        function normalizeTackiness(value) {
            if (typeof value === 'string') {
                const trimmed = value.trim();
                const lower = trimmed.toLowerCase();
                if (lower === 'non-tacky') return 'Non-tacky';
                if (lower === 'tacky') return 'Tacky';
                if (lower === 'hybrid') return 'Hybrid';
            }
            const numeric = parseRatingNumber(value);
            if (Number.isFinite(numeric)) {
                if (numeric >= 6) return 'Tacky';
                if (numeric >= 4) return 'Hybrid';
                return 'Non-tacky';
            }
            return 'Non-tacky';
        }

        const HARDNESS_AVERAGES = {
            Germany: 47.5,
            Japan: 36,
            China: 39
        };
        const HARDNESS_MEDIUM_RANGE = 2;

        function normalizeHardnessCategory(hardnessValue, country) {
            if (!Number.isFinite(hardnessValue)) return null;
            const average = HARDNESS_AVERAGES[country];
            if (!Number.isFinite(average)) return null;
            if (hardnessValue <= average - HARDNESS_MEDIUM_RANGE) return 'Soft';
            if (hardnessValue >= average + HARDNESS_MEDIUM_RANGE) return 'Hard';
            return 'Medium';
        }

        function buildDescriptionMarkdown(raw, debugInfo) {
            const ratings = raw.user_ratings || {};
            const lines = [
                `# ${raw.manufacturer} ${raw.name}`,
                `**Company:** ${raw.manufacturer}`,
                raw.price ? `**Price:** ${raw.price}` : null,
                ratings.overall !== undefined ? `**Overall:** ${ratings.overall}` : null,
                ratings.speed !== undefined ? `**Speed:** ${ratings.speed}` : null,
                ratings.spin !== undefined ? `**Spin:** ${ratings.spin}` : null,
                ratings.control !== undefined ? `**Control:** ${ratings.control}` : null,
                ratings.tackiness ? `**Tackiness:** ${ratings.tackiness}` : null,
                ratings.weight ? `**Weight:** ${ratings.weight}` : null,
                ratings.sponge_hardness ? `**Sponge hardness:** ${ratings.sponge_hardness}` : null
            ].filter(Boolean);
            if (debugInfo) {
                const fmt = value => (Number.isFinite(value) ? value.toFixed(2) : 'n/a');
                const fmtRange = range => {
                    if (!range || !Number.isFinite(range.min) || !Number.isFinite(range.max)) return 'n/a';
                    return `${range.min.toFixed(2)} ‚Üí ${range.max.toFixed(2)}`;
                };
                lines.push(
                    '',
                    '---',
                    '**Debug: speed/spin calculation**',
                    `User spin: ${fmt(debugInfo.userSpin)}`,
                    `User speed: ${fmt(debugInfo.userSpeed)}`,
                    `Manufacturer spin (raw): ${fmt(debugInfo.manufacturerSpinRaw)}`,
                    `Manufacturer speed (raw): ${fmt(debugInfo.manufacturerSpeedRaw)}`,
                    `Manufacturer spin range: ${fmtRange(debugInfo.manufacturerSpinRange)}`,
                    `Manufacturer speed range: ${fmtRange(debugInfo.manufacturerSpeedRange)}`,
                    `Manufacturer spin (normalized): ${fmt(debugInfo.manufacturerSpinNormalized)}`,
                    `Manufacturer speed (normalized): ${fmt(debugInfo.manufacturerSpeedNormalized)}`,
                    `Weights: user ${fmt(debugInfo.userWeight)}, manufacturer ${fmt(debugInfo.manufacturerWeight)}`,
                    `Final spin: ${fmt(debugInfo.spinFinal)}`,
                    `Final speed: ${fmt(debugInfo.speedFinal)}`
                );
            }
            return lines.join('\n');
        }

        function loadJsonFile(url) {
            return new Promise(function(resolve, reject) {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onload = function() {
                    if (xhr.status === 200 || xhr.status === 0) {
                        try {
                            resolve(JSON.parse(xhr.responseText));
                        } catch (e) {
                            reject(new Error('Invalid JSON in ' + url));
                        }
                    } else {
                        reject(new Error('HTTP ' + xhr.status + ' for ' + url));
                    }
                };
                xhr.onerror = function() {
                    reject(new Error('Network error loading ' + url));
                };
                xhr.send();
            });
        }

        const DEBUG_MODE = new URLSearchParams(window.location.search).has('debug');

        async function loadRubberData() {
            const results = await Promise.allSettled(
                rubberFiles.map(function(file) { return loadJsonFile(file); })
            );

            const rawItems = results.flatMap(result => {
                if (result.status === 'fulfilled' && Array.isArray(result.value)) {
                    return result.value;
                }
                console.warn('Skipping rubber data file:', result.reason);
                return [];
            });

            const data = [];
            const descriptionMap = {};
            const manufacturerRanges = buildManufacturerRatingRanges(rawItems);
            const USER_WEIGHT = 0.85;
            const MANUFACTURER_WEIGHT = 0.15;

            rawItems.forEach(raw => {
                const ratings = raw.user_ratings || {};
                const userSpin = parseRatingNumber(ratings.spin);
                const userSpeed = parseRatingNumber(ratings.speed);
                if (!Number.isFinite(userSpin) || !Number.isFinite(userSpeed)) {
                    return;
                }

                const overall = parseRatingNumber(ratings.overall);
                const control = parseRatingNumber(ratings.control);
                const manufacturerRatings = raw.manufacturer_ratings || {};
                const manufacturerRange = manufacturerRanges[raw.manufacturer] || null;
                const manufacturerSpinRaw = parseRatingNumber(manufacturerRatings.spin);
                const manufacturerSpeedRaw = parseRatingNumber(manufacturerRatings.speed);
                const manufacturerSpin = normalizeManufacturerRating(
                    manufacturerSpinRaw,
                    manufacturerRange ? manufacturerRange.spin : null
                );
                const manufacturerSpeed = normalizeManufacturerRating(
                    manufacturerSpeedRaw,
                    manufacturerRange ? manufacturerRange.speed : null
                );
                const spin = Number.isFinite(manufacturerSpin)
                    ? (userSpin * USER_WEIGHT + manufacturerSpin * MANUFACTURER_WEIGHT)
                    : userSpin;
                const speed = Number.isFinite(manufacturerSpeed)
                    ? (userSpeed * USER_WEIGHT + manufacturerSpeed * MANUFACTURER_WEIGHT)
                    : userSpeed;

                const manufacturerDetails = raw.manufacturer_details || {};
                const manufacturerTackiness = manufacturerDetails.tackiness;
                const manufacturerHardness = parseRatingNumber(manufacturerDetails.hardness);
                const manufacturerCountry = manufacturerDetails.country;
                const rubber = {
                    name: raw.name,
                    abbr: raw.abbr || raw.name,
                    company: raw.manufacturer,
                    x: spin * 10,
                    y: speed * 10,
                    weight: parseRatingNumber(ratings.weight),
                    hardness: parseRatingNumber(ratings.sponge_hardness),
                    hardnessCategory: normalizeHardnessCategory(manufacturerHardness, manufacturerCountry),
                    control: control,
                    tackiness: normalizeTackiness(manufacturerTackiness),
                    priority: Number.isFinite(overall) ? overall * 10 : ((spin + speed) / 2) * 10,
                    youtubeUrl: raw.youtube_url || '',
                    productUrl: raw.url || ''
                };

                const debugInfo = DEBUG_MODE ? {
                    userSpin,
                    userSpeed,
                    manufacturerSpinRaw,
                    manufacturerSpeedRaw,
                    manufacturerSpinNormalized: manufacturerSpin,
                    manufacturerSpeedNormalized: manufacturerSpeed,
                    manufacturerSpinRange: manufacturerRange ? manufacturerRange.spin : null,
                    manufacturerSpeedRange: manufacturerRange ? manufacturerRange.speed : null,
                    spinFinal: spin,
                    speedFinal: speed,
                    userWeight: USER_WEIGHT,
                    manufacturerWeight: MANUFACTURER_WEIGHT
                } : null;

                data.push(rubber);
                descriptionMap[rubber.name] = buildDescriptionMarkdown(raw, debugInfo);
            });

            rubberData = data;
            descriptions = descriptionMap;
        }

        // Company colors
        const companyColors = {
            "Butterfly": "#FF6B6B",
            "DHS": "#4ECDC4",
            "Andro": "#95E1D3",
            "JOOLA": "#FFB347",
            "Xiom": "#FFD93D",
            "Tibhar": "#A8E6CF",
            "Nittaku": "#FF8B94",
            "Donic": "#C7CEEA",
            "Yasaka": "#9B59B6"
        };

        // Tackiness markers
        const tackinessMarkers = {
            "Non-tacky": "circle",
            "Tacky": "square",
            "Hybrid": "diamond"
        };

        let selectedRubbers = [];
        let hasPlotted = false;
        let isInternalUpdate = false;
        let currentFilteredData = [];
        let relayoutTimer = null;

        function getCurrentAxisRanges() {
            const chart = document.getElementById('chart');
            if (!chart || !chart.layout || !chart.layout.xaxis || !chart.layout.yaxis) {
                return null;
            }
            const { xaxis, yaxis } = chart.layout;
            if (!Array.isArray(xaxis.range) || !Array.isArray(yaxis.range)) {
                return null;
            }
            return {
                xaxis: [...xaxis.range],
                yaxis: [...yaxis.range]
            };
        }

        function shouldAutoscaleForFilteredData(filteredData, currentRanges) {
            if (!currentRanges || filteredData.length === 0) {
                return false;
            }
            const xMin = currentRanges.xaxis[0];
            const xMax = currentRanges.xaxis[1];
            const yMin = currentRanges.yaxis[0];
            const yMax = currentRanges.yaxis[1];

            return filteredData.some(rubber =>
                rubber.x < xMin || rubber.x > xMax || rubber.y < yMin || rubber.y > yMax
            );
        }

        function getControlValue(rubber) {
            if (typeof rubber.control === 'number') {
                return rubber.control;
            }
            const description = descriptions[rubber.name];
            if (!description) {
                return null;
            }
            const match = description.match(/\*\*Control:\*\*\s*([0-9.]+)/);
            if (!match) {
                return null;
            }
            const value = Number.parseFloat(match[1]);
            return Number.isFinite(value) ? value : null;
        }

        function buildCheckboxOptions(container, values, checkedValues) {
            container.innerHTML = '';
            values.forEach(item => {
                const value = typeof item === 'string' ? item : item.value;
                const labelText = typeof item === 'string' ? item : item.label;
                const swatchColor = typeof item === 'string' ? null : item.swatchColor;
                const shapeSymbol = typeof item === 'string' ? null : item.shapeSymbol;

                const label = document.createElement('label');
                label.className = 'filter-option';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = value;
                checkbox.checked = checkedValues ? checkedValues.has(value) : true;
                label.appendChild(checkbox);

                const indicator = document.createElement('span');
                indicator.className = 'custom-check';
                if (swatchColor) {
                    indicator.classList.add('color-check');
                    indicator.style.setProperty('--swatch-color', swatchColor);
                    indicator.style.backgroundColor = swatchColor;
                }
                if (shapeSymbol) {
                    indicator.classList.add('shape-check', shapeSymbol);
                }
                label.appendChild(indicator);

                const text = document.createElement('span');
                text.textContent = labelText;
                label.appendChild(text);
                container.appendChild(label);
            });
        }

        function setAllChecked(container, checked) {
            Array.from(container.querySelectorAll('input[type="checkbox"]')).forEach(cb => {
                cb.checked = checked;
            });
        }

        function filterOptions(container, query) {
            const q = query.trim().toLowerCase();
            Array.from(container.querySelectorAll('.filter-option')).forEach(option => {
                const text = option.textContent.toLowerCase();
                option.style.display = text.includes(q) ? 'flex' : 'none';
            });
        }

        function getCheckedValues(containerId) {
            return Array.from(document.querySelectorAll(`#${containerId} input[type="checkbox"]:checked`))
                .map(cb => cb.value);
        }

        function buildNameOptionsFromCompanies() {
            const nameFilter = document.getElementById('nameFilter');
            const selectedCompanies = getCheckedValues('companyFilter');
            const previousSelections = new Set(getCheckedValues('nameFilter'));
            const previousNames = new Set(
                Array.from(nameFilter.querySelectorAll('input[type="checkbox"]')).map(cb => cb.value)
            );

            if (selectedCompanies.length === 0) {
                nameFilter.innerHTML = '<div class="filter-instructions">Select a company first.</div>';
                return;
            }

            const names = rubberData
                .filter(rubber => selectedCompanies.includes(rubber.company))
                .map(rubber => rubber.name);
            const uniqueNames = [...new Set(names)].sort();
            const nameOptions = uniqueNames.map(name => {
                const rubber = rubberData.find(item => item.name === name);
                const company = rubber ? rubber.company : null;
                return {
                    value: name,
                    label: name,
                    swatchColor: company ? getCompanyColor(company) : null
                };
            });

            buildCheckboxOptions(
                nameFilter,
                nameOptions,
                new Set(
                    uniqueNames.filter(name => {
                        if (previousSelections.has(name)) return true;
                        if (previousNames.has(name)) return false;
                        return true;
                    })
                )
            );
        }

        function getCompanyColor(company) {
            return companyColors[company] || '#999999';
        }

        function getTackinessSymbol(tackiness) {
            return tackinessMarkers[tackiness] || 'circle';
        }

        // Initialize filters
        function initFilters() {
            const companies = [...new Set(rubberData.map(r => r.company))].sort();
            const tackinessValues = ["Non-tacky", "Tacky", "Hybrid"];
            const hardnessValues = ["Soft", "Medium", "Hard"];
            const companyOptions = companies.map(company => ({
                value: company,
                label: company,
                swatchColor: getCompanyColor(company)
            }));
            const tackinessOptions = tackinessValues.map(tackiness => ({
                value: tackiness,
                label: tackiness,
                shapeSymbol: getTackinessSymbol(tackiness)
            }));
            const hardnessOptions = hardnessValues.map(hardness => ({
                value: hardness,
                label: hardness
            }));

            const companyFilter = document.getElementById('companyFilter');
            const nameFilter = document.getElementById('nameFilter');
            const tackinessFilter = document.getElementById('tackinessFilter');
            const hardnessFilter = document.getElementById('hardnessFilter');

            buildCheckboxOptions(companyFilter, companyOptions);
            buildCheckboxOptions(tackinessFilter, tackinessOptions);
            buildCheckboxOptions(hardnessFilter, hardnessOptions);
            buildNameOptionsFromCompanies();

            companyFilter.addEventListener('change', () => {
                buildNameOptionsFromCompanies();
                updateChart();
            });
            nameFilter.addEventListener('change', updateChart);
            tackinessFilter.addEventListener('change', updateChart);
            hardnessFilter.addEventListener('change', updateChart);

            document.getElementById('companySearch').addEventListener('input', (e) => {
                filterOptions(companyFilter, e.target.value);
            });
            document.getElementById('nameSearch').addEventListener('input', (e) => {
                filterOptions(nameFilter, e.target.value);
            });

            document.querySelectorAll('.filter-actions button').forEach(button => {
                button.addEventListener('click', () => {
                    const filter = button.dataset.filter;
                    const action = button.dataset.action;
                    const container = document.getElementById(`${filter}Filter`);
                    setAllChecked(container, action === 'all');
                    if (filter === 'company') {
                        buildNameOptionsFromCompanies();
                    }
                    updateChart();
                });
            });
        }

        // Get filtered data
        function getFilteredData() {
            const selectedCompanies = getCheckedValues('companyFilter');
            const selectedNames = getCheckedValues('nameFilter');
            const selectedTackiness = getCheckedValues('tackinessFilter');
            const selectedHardness = getCheckedValues('hardnessFilter');

            if (
                selectedCompanies.length === 0 ||
                selectedNames.length === 0 ||
                selectedTackiness.length === 0 ||
                selectedHardness.length === 0
            ) {
                return [];
            }

            return rubberData.filter(rubber => {
                if (selectedCompanies.length > 0 && !selectedCompanies.includes(rubber.company)) return false;
                if (selectedNames.length > 0 && !selectedNames.includes(rubber.name)) return false;
                if (selectedTackiness.length > 0 && !selectedTackiness.includes(rubber.tackiness)) return false;
                if (selectedHardness.length > 0 && !selectedHardness.includes(rubber.hardnessCategory)) return false;
                return true;
            });
        }

        // Compute which rubbers to display based on overlap & priority
        function computeVisibleRubbers(filteredData) {
            if (filteredData.length === 0) return [];

            const chartEl = document.getElementById('chart');
            let xRange, yRange, plotWidth, plotHeight;

            if (chartEl._fullLayout && chartEl._fullLayout.xaxis && chartEl._fullLayout.yaxis) {
                const xa = chartEl._fullLayout.xaxis;
                const ya = chartEl._fullLayout.yaxis;
                xRange = [xa.range[0], xa.range[1]];
                yRange = [ya.range[0], ya.range[1]];
                const size = chartEl._fullLayout._size;
                plotWidth = size.w;
                plotHeight = size.h;
            } else {
                // First render ‚Äî estimate from data bounds and container size
                const xs = filteredData.map(r => r.x);
                const ys = filteredData.map(r => r.y);
                const pad = 2;
                xRange = [Math.min(...xs) - pad, Math.max(...xs) + pad];
                yRange = [Math.min(...ys) - pad, Math.max(...ys) + pad];
                const rect = chartEl.getBoundingClientRect();
                plotWidth = rect.width * 0.82;
                plotHeight = rect.height * 0.82;
            }

            const xSpan = xRange[1] - xRange[0];
            const ySpan = yRange[1] - yRange[0];
            if (xSpan <= 0 || ySpan <= 0) return filteredData;

            function toPixel(dataX, dataY) {
                const px = ((dataX - xRange[0]) / xSpan) * plotWidth;
                const py = ((dataY - yRange[0]) / ySpan) * plotHeight;
                return { px, py };
            }

            // Sort by priority descending ‚Äî higher priority dots are placed first
            const sorted = [...filteredData].sort((a, b) => b.priority - a.priority);
            const visible = [];
            const occupied = []; // pixel positions already taken

            // Minimum pixel distance thresholds (accounts for dot + text label)
            const MIN_DIST_X = 55;
            const MIN_DIST_Y = 24;

            for (const rubber of sorted) {
                const { px, py } = toPixel(rubber.x, rubber.y);

                let overlaps = false;
                for (const occ of occupied) {
                    if (Math.abs(px - occ.px) < MIN_DIST_X && Math.abs(py - occ.py) < MIN_DIST_Y) {
                        overlaps = true;
                        break;
                    }
                }

                if (!overlaps) {
                    visible.push(rubber);
                    occupied.push({ px, py });
                }
            }

            return visible;
        }

        // Initialize chart with Plotly
        function initChart() {
            updateChart();
        }

        // Update chart
        function updateChart(options) {
            const settings = options || {};
            const filteredData = getFilteredData();
            currentFilteredData = filteredData;
            const visibleData = computeVisibleRubbers(filteredData);
            const controlValues = filteredData
                .map(getControlValue)
                .filter(value => Number.isFinite(value));
            const minControl = controlValues.length > 0 ? Math.min(...controlValues) : null;
            const maxControl = controlValues.length > 0 ? Math.max(...controlValues) : null;
            const minMarkerSize = 10;
            const maxMarkerSize = 15;

            function getMarkerSize(rubber) {
                const control = getControlValue(rubber);
                if (!Number.isFinite(control) || minControl === null || maxControl === null) {
                    return 12;
                }
                if (maxControl === minControl) {
                    return (minMarkerSize + maxMarkerSize) / 2;
                }
                const t = (control - minControl) / (maxControl - minControl);
                return minMarkerSize + t * (maxMarkerSize - minMarkerSize);
            }
            
            // Group data by company and tackiness
            const traces = [];
            const groups = {};
            
            visibleData.forEach(rubber => {
                const key = `${rubber.company}-${rubber.tackiness}`;
                if (!groups[key]) {
                    groups[key] = {
                        company: rubber.company,
                        tackiness: rubber.tackiness,
                        rubbers: []
                    };
                }
                groups[key].rubbers.push(rubber);
            });

            // Create traces for each group
            Object.values(groups).forEach(group => {
                const trace = {
                    x: group.rubbers.map(r => r.x),
                    y: group.rubbers.map(r => r.y),
                    mode: 'markers+text',
                    type: 'scatter',
                    name: `${group.company} (${group.tackiness})`,
                    marker: {
                        size: group.rubbers.map(r => getMarkerSize(r)),
                        color: getCompanyColor(group.company),
                        symbol: getTackinessSymbol(group.tackiness),
                        line: {
                            width: 1,
                            color: '#fff'
                        }
                    },
                    text: group.rubbers.map(r => r.abbr),
                    textposition: 'top center',
                    textfont: {
                        size: 11,
                        color: '#333',
                        family: 'Arial, sans-serif'
                    },
                    hovertemplate: '<b>%{customdata.name}</b><br>' +
                        'Company: ' + group.company + '<br>' +
                        'Speed: %{x}<br>' +
                        'Spin: %{y}<br>' +
                        'Tackiness: ' + group.tackiness +
                        '<extra></extra>',
                    customdata: group.rubbers
                };
                traces.push(trace);
            });

            let currentRanges = hasPlotted ? getCurrentAxisRanges() : null;
            if (!settings.preserveRanges && shouldAutoscaleForFilteredData(filteredData, currentRanges)) {
                currentRanges = null;
            }
            const layout = {
                title: '',
                dragmode: 'pan',
                xaxis: {
                    title: 'Spin ‚Üí',
                    autorange: currentRanges ? false : true,
                    range: currentRanges ? currentRanges.xaxis : undefined,
                    zeroline: false,
                    gridcolor: '#eee'
                },
                yaxis: {
                    title: 'Speed ‚Üí',
                    autorange: currentRanges ? false : true,
                    range: currentRanges ? currentRanges.yaxis : undefined,
                    zeroline: false,
                    gridcolor: '#eee'
                },
                hovermode: 'closest',
                plot_bgcolor: 'white',
                paper_bgcolor: 'white',
                margin: { l: 60, r: 40, t: 40, b: 60 },
                showlegend: false,
                legend: {
                    x: 1,
                    y: 1,
                    xanchor: 'right',
                    bgcolor: 'rgba(255,255,255,0.8)',
                    bordercolor: '#ddd',
                    borderwidth: 1
                }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: [
                    'lasso2d',
                    'select2d',
                    'pan2d',
                    'autoscale2d',
                    'resetScale2d',
                    'toImage',
                    'zoom2d',
                    'zoomIn2d',
                    'zoomOut2d'
                ],
                modeBarButtonsToAdd: [{
                    name: 'Autoscale',
                    title: 'Autoscale',
                    icon: Plotly.Icons.autoscale,
                    click: function(gd) {
                        Plotly.relayout(gd, {
                            'xaxis.autorange': true,
                            'yaxis.autorange': true
                        });
                    }
                }],
                displaylogo: false,
                scrollZoom: false
            };

            if (hasPlotted) {
                Plotly.react('chart', traces, layout, config);
            } else {
                Plotly.newPlot('chart', traces, layout, config);
                hasPlotted = true;
            }

            // Add click handler
            const chartEl = document.getElementById('chart');
            chartEl.on('plotly_click', function(data) {
                const point = data.points[0];
                const pointIndex = point.pointIndex;
                const rubber = point.data.customdata[pointIndex];
                handleRubberClick(rubber);
            });

            // Add relayout handler (once) to recalculate visibility on zoom/pan
            if (!chartEl._hasRelayoutHandler) {
                chartEl._hasRelayoutHandler = true;
                chartEl.on('plotly_relayout', function(eventData) {
                    if (isInternalUpdate) return;
                    const rangesChanged =
                        eventData['xaxis.range[0]'] !== undefined ||
                        eventData['xaxis.range'] !== undefined ||
                        eventData['yaxis.range[0]'] !== undefined ||
                        eventData['yaxis.range'] !== undefined ||
                        eventData['xaxis.autorange'] !== undefined ||
                        eventData['yaxis.autorange'] !== undefined;
                    if (rangesChanged) {
                        clearTimeout(relayoutTimer);
                        relayoutTimer = setTimeout(function() {
                            isInternalUpdate = true;
                            updateChart({ preserveRanges: true });
                            setTimeout(function() { isInternalUpdate = false; }, 300);
                        }, 120);
                    }
                });
            }
        }

        // Handle rubber click
        function handleRubberClick(rubber) {
            if (selectedRubbers.length === 0) {
                selectedRubbers.push(rubber);
                updateDetailPanel(1, rubber);
            } else if (selectedRubbers.length === 1) {
                if (selectedRubbers[0].name === rubber.name) {
                    return;
                }
                selectedRubbers.push(rubber);
                updateDetailPanel(2, rubber);
                showComparison();
            } else {
                selectedRubbers = [rubber];
                updateDetailPanel(1, rubber);
                clearDetailPanel(2);
                hideComparison();
            }
        }

        // Update detail panel
        function updateDetailPanel(panelNum, rubber) {
            const panel = document.getElementById(`detail${panelNum}`);
            const markdown = descriptions[rubber.name] || `# ${rubber.name}\n\nNo description available.`;
            const html = marked.parse(markdown);

            const links = [];
            if (rubber.youtubeUrl) {
                links.push(`<a href="${rubber.youtubeUrl}" target="_blank" style="margin-right: 15px;">üì∫ Watch Review</a>`);
            }
            if (rubber.productUrl) {
                links.push(`<a href="${rubber.productUrl}" target="_blank">üîó Product Page</a>`);
            }

            const linksHtml = links.length > 0 ? `
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
                    <strong>Links:</strong><br/>
                    ${links.join('')}
                </div>
            ` : '';

            panel.innerHTML = html + linksHtml;
        }

        // Clear detail panel
        function clearDetailPanel(panelNum) {
            const panel = document.getElementById(`detail${panelNum}`);
            panel.innerHTML = `<h3>Select another rubber</h3><div class="content">Click on another dot to compare</div>`;
        }

        // Show comparison
        function showComparison() {
            const bar = document.getElementById('comparisonBar');
            bar.textContent = `${selectedRubbers[0].name} vs ${selectedRubbers[1].name}`;
            bar.style.display = 'block';
        }

        // Hide comparison
        function hideComparison() {
            document.getElementById('comparisonBar').style.display = 'none';
        }

        // Trackpad pinch-to-zoom (blocks regular scroll zoom)
        (function() {
            const chartEl = document.getElementById('chart');

            chartEl.addEventListener('wheel', function(e) {
                // ctrlKey is true for trackpad pinch gestures
                if (!e.ctrlKey) return; // ignore regular scroll ‚Äî do nothing

                e.preventDefault();

                const gd = chartEl;
                if (!gd._fullLayout) return;

                const xa = gd._fullLayout.xaxis;
                const ya = gd._fullLayout.yaxis;
                const plotArea = gd._fullLayout._size;
                const rect = gd.getBoundingClientRect();

                const plotLeft = rect.left + plotArea.l;
                const plotTop = rect.top + plotArea.t;
                const plotWidth = plotArea.w;
                const plotHeight = plotArea.h;

                // Fraction of cursor within plot area
                const fx = Math.max(0, Math.min(1, (e.clientX - plotLeft) / plotWidth));
                const fy = Math.max(0, Math.min(1, 1 - (e.clientY - plotTop) / plotHeight));

                // Zoom factor: positive deltaY = zoom out, negative = zoom in
                const zoomSpeed = 0.01;
                const scale = 1 + e.deltaY * zoomSpeed;

                const xRange = [xa.range[0], xa.range[1]];
                const yRange = [ya.range[0], ya.range[1]];
                const xSpan = xRange[1] - xRange[0];
                const ySpan = yRange[1] - yRange[0];

                const newXSpan = xSpan * scale;
                const newYSpan = ySpan * scale;

                const xCenter = xRange[0] + fx * xSpan;
                const yCenter = yRange[0] + fy * ySpan;

                const newXRange = [
                    xCenter - fx * newXSpan,
                    xCenter + (1 - fx) * newXSpan
                ];
                const newYRange = [
                    yCenter - fy * newYSpan,
                    yCenter + (1 - fy) * newYSpan
                ];

                Plotly.relayout(chartEl, {
                    'xaxis.range': newXRange,
                    'yaxis.range': newYRange,
                    'xaxis.autorange': false,
                    'yaxis.autorange': false
                });
            }, { passive: false });
        })();

        // Pinch-to-zoom for mobile
        (function() {
            const chartEl = document.getElementById('chart');
            let pinchStartDist = null;
            let pinchStartRanges = null;
            let pinchCenter = null;

            function getTouchDist(t1, t2) {
                const dx = t1.clientX - t2.clientX;
                const dy = t1.clientY - t2.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }

            function getTouchCenter(t1, t2) {
                return {
                    x: (t1.clientX + t2.clientX) / 2,
                    y: (t1.clientY + t2.clientY) / 2
                };
            }

            function getPlotFraction(clientX, clientY) {
                // Convert client coordinates to fraction within the plot area
                const gd = chartEl;
                const xa = gd._fullLayout.xaxis;
                const ya = gd._fullLayout.yaxis;
                const plotArea = gd._fullLayout._size;
                const rect = gd.getBoundingClientRect();

                const plotLeft = rect.left + plotArea.l;
                const plotTop = rect.top + plotArea.t;
                const plotWidth = plotArea.w;
                const plotHeight = plotArea.h;

                const fx = (clientX - plotLeft) / plotWidth;
                const fy = 1 - (clientY - plotTop) / plotHeight; // invert y
                return { fx: Math.max(0, Math.min(1, fx)), fy: Math.max(0, Math.min(1, fy)) };
            }

            chartEl.addEventListener('touchstart', function(e) {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const t1 = e.touches[0];
                    const t2 = e.touches[1];
                    pinchStartDist = getTouchDist(t1, t2);
                    pinchCenter = getTouchCenter(t1, t2);

                    const gd = chartEl;
                    if (gd._fullLayout) {
                        const xa = gd._fullLayout.xaxis;
                        const ya = gd._fullLayout.yaxis;
                        pinchStartRanges = {
                            x: [xa.range[0], xa.range[1]],
                            y: [ya.range[0], ya.range[1]]
                        };
                    }
                }
            }, { passive: false });

            chartEl.addEventListener('touchmove', function(e) {
                if (e.touches.length === 2 && pinchStartDist && pinchStartRanges) {
                    e.preventDefault();
                    const t1 = e.touches[0];
                    const t2 = e.touches[1];
                    const currentDist = getTouchDist(t1, t2);

                    // zoom factor: >1 means zooming in, <1 means zooming out
                    const scale = pinchStartDist / currentDist;

                    // Get the fractional position of the pinch center within the plot
                    const frac = getPlotFraction(pinchCenter.x, pinchCenter.y);

                    const xRange = pinchStartRanges.x;
                    const yRange = pinchStartRanges.y;
                    const xSpan = xRange[1] - xRange[0];
                    const ySpan = yRange[1] - yRange[0];

                    const newXSpan = xSpan * scale;
                    const newYSpan = ySpan * scale;

                    // Keep the pinch center point fixed
                    const xCenter = xRange[0] + frac.fx * xSpan;
                    const yCenter = yRange[0] + frac.fy * ySpan;

                    const newXRange = [
                        xCenter - frac.fx * newXSpan,
                        xCenter + (1 - frac.fx) * newXSpan
                    ];
                    const newYRange = [
                        yCenter - frac.fy * newYSpan,
                        yCenter + (1 - frac.fy) * newYSpan
                    ];

                    Plotly.relayout(chartEl, {
                        'xaxis.range': newXRange,
                        'yaxis.range': newYRange,
                        'xaxis.autorange': false,
                        'yaxis.autorange': false
                    });
                }
            }, { passive: false });

            chartEl.addEventListener('touchend', function(e) {
                if (e.touches.length < 2) {
                    pinchStartDist = null;
                    pinchStartRanges = null;
                    pinchCenter = null;
                }
            });
        })();

        // Initialize
        window.addEventListener('resize', function() {
            Plotly.Plots.resize('chart');
        });

        async function initializeApp() {
            const chart = document.getElementById('chart');
            if (chart) {
                chart.innerHTML = '<div style="padding: 20px; color: #888;">Loading rubber data‚Ä¶</div>';
            }

            try {
                await loadRubberData();
            } catch (error) {
                console.error('Failed to load rubber data:', error);
            }

            if (rubberData.length === 0) {
                const isFileProtocol = window.location.protocol === 'file:';
                const msg = isFileProtocol
                    ? 'Could not load rubber data from JSON files.<br><br>' +
                      'Opening this page via <code>file://</code> blocks file loading in most browsers.<br>' +
                      'Start a local server instead:<br>' +
                      '<pre style="margin-top:8px;background:#f5f5f5;padding:8px;border-radius:4px;">cd ' +
                      window.location.pathname.replace(/\/[^/]*$/, '') +
                      '\npython3 -m http.server</pre>' +
                      'Then open <a href="http://localhost:8000">http://localhost:8000</a>'
                    : 'Failed to load rubber data. Check the browser console for details.';
                if (chart) {
                    chart.innerHTML = '<div style="padding: 20px; color: #c00; line-height: 1.6;">' + msg + '</div>';
                }
                return;
            }

            if (chart) {
                chart.innerHTML = '';
            }
            initFilters();
            initChart();
        }

        initializeApp();
    </script>
</body>
</html>
